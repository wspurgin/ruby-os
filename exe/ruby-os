#!/usr/bin/env ruby

begin
  require 'ruby-os'
rescue LoadError
  lib = File.expand_path('../../lib', __FILE__)
  $LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
  retry
end

class RubyOS::Simulation
  attr_accessor :manager, :scheduler

  def self.run
    self.new.run
  end

  def initialize
    # Initialize Queue manager and basic queues
    @manager = RubyOS::QueueManager.new
    @manager.add_queue :ready
    @manager.add_queue :waiting
  end

  def run
    procs = if ARGV.count > 0
              file = ARGV[0]
              read_input_file(file)
            else
              []
            end

    puts "Initializing Queues"

    procs.each_with_index do |pcb, i|
      case pcb.state
      when "ready"
        ready_queue.push pcb
      when "waiting"
        waiting_queue.push pcb
      else
        puts "Unrecognized state: '#{pcb.state}'. Using 'ready' by default"
        pcb.update_state('ready')
        ready_queue.push pcb
      end
    end

    print_queues

    puts "This is RubyOS, a simulated OS written in Ruby âœ“"
    loop do
      cmd, args = ask_user_input.split(" ")
      break if !handle(cmd, args)
    end
  end

  def read_input_file(file)
    procs = []
    File.open(file, 'r') do |input|
      pcb_strings = input.readlines
      procs = pcb_strings.map do |pcb_string|
        pcb_pieces = pcb_string.split(',').map(&:strip)
        if pcb_pieces.count < 3
          puts "File PCB input was unrecognized, expected format: pid,execution_address,state[,options], see docs for details."
          next
        end
        pid, pc, state, *option_args = pcb_pieces
        begin
          pid = Integer(pid)
          pc = Integer(pc)
        rescue ArgumentError
          puts "File PCB input was unrecognized, expected format: pid,execution_address,state[,options], see docs for details."
          next
        end
        options_bad = false
        option_args = Array.wrap(option_args)
        options = {
          wait_time: 0
        }
        option_args.each do |option_pair|
          option, value = option_pair.split(":").map(&:strip)
          option = option.to_sym
          if value.nil? || option.nil?
            puts "Option format unrecognized, for #{pcb_string}. See docs for expected format"
          end
          begin
            options[option] = Integer(value)
          rescue ArgumentError
            if option =~ /^remaining_processing_time/ || option =~ /^priority/
              puts "#{option} is a defined option that requires integer input"
              options_bad = true
              break
            end
            options[option] = value
          end
        end
        next if options_bad
        options.merge!({ state: state })
        RubyOS::PCB.new(pid, pc, options)
      end
    end
    procs.compact
  rescue IOError => e
    puts e
    return []
  end

  def ask_user_input
    puts "Enter Commands (enter help for usage)"
    $stdout << ">"
    $stdin.gets.chomp
  end

  def handle(cmd, *args)
    case cmd
    when "help"
      print_usage
    when "add_proc"
      add_proc_interactively
    when "delete_proc"
      delete_proc_interactively
    when "show_queues"
      print_queues
    when "simulate"
      simulate(args)
    when "exit", "quit"
      return false
    else
      puts "Unknown Command"
      print_usage
    end
  end

  def simulate(args)
    request = args.any? ? args.first.strip : "srpt"
    orig_manager = deep_copy_manager
    @scheduler = case request
                when /^s((rpt)|(jf))?/i
                  RubyOS::SrptScheduler.new manager
                when /^r(obin)?/i
                  q = 2
                  puts "Enter time share window, q: (hit enter to use default of 2)"
                  begin
                    print ">"
                    ans = $stdin.gets.chomp
                    q = Integer(ans) if !ans.empty?
                  rescue ArgumentError
                    puts "Value entered is not an integer, please enter integer value"
                    retry
                  end
                  RubyOS::RobinScheduler.new manager, q
                when /^p(riority)?/i
                  RubyOS::PriorityScheduler.new manager
                else
                  puts "Unrecognized scheduler, choices are srpt, robin, priority"
                  return true
                end
    puts "Beginning simulation with #{scheduler.class}"
    completed_procs = []
    avg_waiting_time = 0.0
    number_of_context_switches = 0
    total_procs = ready_queue.count + waiting_queue.count

    # Estimate number of iterations
    max_iterations = (total_procs + ready_queue.sum(&:remaining_processing_time) + waiting_queue.sum(&:remaining_processing_time)) * 10
    puts "Max iterations calculated from process time: #{max_iterations}"

    ready_queue.each { |pcb| pcb.accounting_information[:wait_time] = 0 }
    waiting_queue.each { |pcb| pcb.accounting_information[:wait_time] = 0 }

    current_proc = scheduler.next_proc(:ready)
    log = $stdout
    max_iterations.times do

      # Get the next proc
      next_proc = scheduler.next_proc(:ready, current_proc)
      break if next_proc.nil? && waiting_queue.empty?

      # If we reached this point, there are still processes in the waiting queue
      # but we have no current process or next process yet, so we should skip
      # the context switch and current_proc update steps
      if !next_proc.nil?
        if current_proc.nil? || next_proc != current_proc
          number_of_context_switches += 1
          log.puts "Perfroming context switch with #{next_proc}"
          ready_queue.push current_proc if !current_proc.nil?
          current_proc = next_proc
        end

        current_proc.accounting_information[:remaining_processing_time] -= 1

        if current_proc.remaining_processing_time <= 0
          log.puts "#{current_proc} Completed"

          # place proc in simulated 'success' and 'Free' proc
          completed_procs << current_proc
          current_proc = nil
        end
      end

      log.puts "Current Proc in CPU: #{current_proc}" if !current_proc.nil?

      # NOTE for now, at the end of each cycle one process is moved from the
      # waiting queue to the ready queue.
      if waiting_queue.any?
        _pcb = waiting_queue.pop
        _pcb.update_state("ready")
        ready_queue.push _pcb
        log.puts "New arrival to the :ready queue from the waiting queue. #{_pcb}"
      end

      # Increment all wait times
      ready_queue.each { |pcb| pcb.accounting_information[:wait_time] += 1 }
      waiting_queue.each { |pcb| pcb.accounting_information[:wait_time] += 1 }

      log.puts "Ready Queue: #{ready_queue}" if ready_queue.any?
    end

    if waiting_queue.any? || ready_queue.any? || !current_proc.nil?
      puts "Simulation did not finish within #{max_iterations} iterations."
      puts "This just means that our estimation for max iterations was off."
      puts "The average wait time will still be calculated."
    end
    puts "Completed Procs: #{completed_procs.inspect}"
    avg_waiting_time = completed_procs.sum(&:wait_time)
    avg_waiting_time += ready_queue.sum(&:wait_time) if ready_queue.any?
    avg_waiting_time += waiting_queue.sum(&:wait_time) if waiting_queue.any?
    divsor = total_procs > 0 ? total_procs : 1
    avg_waiting_time = avg_waiting_time / divsor
    avg_context_switches = number_of_context_switches.to_f / divsor

    puts "\n\nThe Results using the #{scheduler.class} are here:"
    puts "Average Wait Time: #{avg_waiting_time} time units"
    puts "Average Context Switches per Process: #{avg_context_switches}"
    puts "Total Number of Context Switches: #{number_of_context_switches}"
    puts "Total Processes: #{total_procs}"
    puts "Total Completed Procs: #{completed_procs.count}"

    @manager = orig_manager
  end

  # Ruby is a pass-by-value language, *but* all those values (by default) are
  # references to memory locations. As such we have to duplicate all the PCBs
  # and rebuild the Queues and Manager to duplicate the manager. All Ruby
  # objects have a 'dup' method, but that only does a shallow copy.
  def deep_copy_manager
    dup_ready_queue = RubyOS::Queue.new ready_queue.map { |pcb| RubyOS::PCB.new pcb.pid, pcb.pc, pcb.accounting_information.dup }
    dup_waiting_queue = RubyOS::Queue.new waiting_queue.map { |pcb| RubyOS::PCB.new pcb.pid, pcb.pc, pcb.accounting_information.dup }
    mapping = { ready: dup_ready_queue, waiting: dup_waiting_queue }
    RubyOS::QueueManager.new mapping
  end

  def print_queues
    puts "Ready Queue: #{ready_queue}"
    puts "Waiting Queue: #{waiting_queue}"
    true
  end

  def print_usage
    puts "The following are the accepted commands:"
    puts "help        - prints this usuage guide"
    puts "add_proc    - interactively adds a process to a queue"
    puts "delete_proc - interactively remove a process from a queue"
    puts "show_queues - prints queues to STDOUT"
    puts "simulate [scheduler] - runs simulation with the given scheduler. Choices are sjf, robin, priority. Default is sjf."
    puts "exit        - quits the program"
    puts "quit        - alias for exit"
    true
  end

  def add_proc_interactively
    pid = 0
    addr = 0x0
    options = {
      state: "ready",
      priority: 4,
      remaining_processing_time: 8,
      wait_time: 0
    }
    queue = nil

    puts "Enter process id"
    begin
      print ">"
      pid = Integer($stdin.gets.chomp)
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    puts "Enter starting address (e.g. 0x2) (hit enter to use default)"
    begin
      print ">"
      ans = $stdin.gets.chomp
      addr = Integer(ans) if !ans.empty?
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    puts "Enter process' priority (hit enter to use default of 4)"
    begin
      print ">"
      ans = $stdin.gets.chomp
      options[:priority] = Integer(ans) if !ans.empty?
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    puts "Enter process' remaining processing time (hit enter to use default of 8)"
    begin
      print ">"
      ans = $stdin.gets.chomp
      options[:remaining_processing_time] = Integer(ans) if !ans.empty?
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    puts "Which queue do you want to add the process to? ('waiting', or 'ready')"
    begin
      print ">"
      state = $stdin.gets.chomp
      case state
      when /^w(aiting)?/i
        options[:state] = "waiting"
        queue = waiting_queue
      when /^r(eady)?/i
        options[:state] = "ready"
        queue = ready_queue
      else
        raise ArgumentError.new "state must be either 'ready' or 'waiting'"
      end
    rescue
      puts "Unrecognized queue '#{state}', please enter a valid queue (ready,waiting)"
      retry
    end

    pcb = RubyOS::PCB.new(pid, addr, options)
    puts "Enter the position you wish to insert the process (hit enter to use the default location)"
    begin
      print ">"
      pos = $stdin.gets.chomp
      pos = if pos.empty?
              nil
            else
              Integer(pos)
            end
      queue.push(pcb, pos)
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    print_queues
    true
  end

  def delete_proc_interactively
    queue = nil

    puts "Which queue do you want to delete from? ('waiting', or 'ready')"
    begin
      print ">"
      state = $stdin.gets.chomp
      case state
      when /^w(aiting)?/i
        state = "waiting"
        queue = waiting_queue
      when /^r(eady)?/i
        state = "ready"
        queue = ready_queue
      else
        raise ArgumentError.new "state must be either 'ready' or 'waiting'"
      end
    rescue
      puts "Unrecognized queue '#{state}', please enter a valid queue (ready,waiting)"
      retry
    end

    puts "Enter the PID of the process you wish to remove (hit enter to use the default location)"
    begin
      print ">"
      pos = $stdin.gets.chomp
      pos = if pos.empty?
              nil
            else
              Integer(pos)
            end
      pcb = queue.pop(pos)
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    if pcb.nil?
      puts "No process was removed (possible gave a PID that didn't exist?)"
    else
      puts "Remove process: #{pcb}"
    end

    print_queues
    true
  end

  private

  def ready_queue
    manager[:ready]
  end

  def waiting_queue
    manager[:waiting]
  end

end

RubyOS::Simulation.run
