#!/usr/bin/env ruby

require 'readline'

begin
  require 'ruby-os'
rescue LoadError
  lib = File.expand_path('../../lib', __FILE__)
  $LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
  retry
end

class RubyOS::Simulation
  attr_accessor :manager, :scheduler, :memory

  def self.run
    self.new.run
  end

  def initialize
    # Initialize Queue manager and basic queues
    @manager = RubyOS::QueueManager.new
    @manager.add_queue :ready
    @manager.add_queue :waiting
    @manager.add_queue :blocked
  end

  def run

    puts "Initializing Queues and Processes"

    if ARGV.count > 0
      file = ARGV[0]
      load_pcbs(file)
    else
      print_all
    end

    Readline.completion_proc = Proc.new do |str|
      # TODO make smarter so that if a command is already specified, use either
      # defined inputs into those commands or just files.
      defined_commands.grep(/^#{Regexp.escape(str)}/) +
      Dir[str+'*'].grep(/^#{Regexp.escape(str)}/)
    end

    puts "This is RubyOS, a simulated OS written in Ruby âœ“"
    while line = Readline.readline('> ', true)
      cmd, args = line.split(" ")
      break if !handle(cmd, args)
    end
  end

  def load_pcbs(file)

    processes = read_input_file(file)

    processes.each_with_index do |pcb, i|
      if !["ready", "waiting"].include? pcb.state
        puts "Unrecognized state: '#{pcb.state}'. Using 'ready' by default"
        pcb.update_state('ready')
      end
      if procs.include? pcb.pid
        puts "Proc with #{pcb.pid} already exists, throwing this process out."
        next
      end
      procs.push pcb
    end
    sort_process_by_arrival!

    puts
    print_all
    puts

    true
  end

  def read_input_file(file)
    procs = []
    File.open(file, 'r') do |input|
      pcb_strings = input.readlines
      procs = pcb_strings.map do |pcb_string|
        pcb_pieces = pcb_string.split(',').map(&:strip)
        if pcb_pieces.count < 3
          puts "File PCB input was unrecognized, expected format: pid,execution_address,state:[,options], see docs for details."
          next
        end
        pid, state, *option_args = pcb_pieces
        begin
          pid = Integer(pid)
        rescue ArgumentError
          puts "File PCB input was unrecognized, expected format: pid,execution_address,state[,options], see docs for details."
          next
        end
        options_bad = false
        option_args = Array.wrap(option_args)
        options = {
          wait_time: 0
        }
        option_args.each do |option_pair|
          option, value = option_pair.split(":").map(&:strip)
          option = option.to_sym
          if value.nil? || option.nil?
            puts "Option format unrecognized, for #{pcb_string}. See docs for expected format"
          end
          begin
            options[option] = Integer(value)
          rescue ArgumentError
            if option =~ /^(remaining_processing_time|priority|arrival_time|memory_required)/
              puts "#{option} is a defined option that requires integer input"
              options_bad = true
              break
            end
            options[option] = value
          end
        end
        next if options_bad
        options.merge!({ state: state, wait_time: 0 })
        RubyOS::PCB.new(pid, options)
      end
    end
    procs.compact
  rescue IOError => e
    puts e
    return []
  end

  def handle(cmd, *args)
    case cmd
    when "help"
      print_usage
    when "add_proc"
      add_proc_interactively
    when "delete_proc"
      delete_proc_interactively
    when "show_queues"
      print_queues
    when "show_procs"
      print_all
    when "simulate"
      simulate(args)
    when "load_pcbs"
      load_pcbs(args.first)
    when "exit", "quit"
      return false
    else
      puts "Unknown Command"
      print_usage
    end
  end

  def simulate(args)
    request = args.any? ? args.first.strip : "srpt"
    orig_manager = deep_copy_manager
    @scheduler = case request
                when /^s((rpt)|(jf))?/i
                  RubyOS::SrptScheduler.new manager
                when /^r(obin)?/i
                  q = 2
                  puts "Enter time share window, q: (hit enter to use default of 2)"
                  begin
                    print ">"
                    ans = $stdin.gets.chomp
                    q = Integer(ans) if !ans.empty?
                  rescue ArgumentError
                    puts "Value entered is not an integer, please enter integer value"
                    retry
                  end
                  RubyOS::RobinScheduler.new manager, q
                when /^p(riority)?/i
                  RubyOS::PriorityScheduler.new manager
                else
                  puts "Unrecognized scheduler, choices are srpt, robin, priority"
                  return true
                end
    puts "Beginning simulation with #{scheduler.class}"
    completed_procs = []
    avg_waiting_time = 0.0
    number_of_context_switches = 0
    total_procs = ready_queue.count + waiting_queue.count

    # Estimate number of iterations
    max_iterations = (total_procs + ready_queue.sum(&:remaining_processing_time) + waiting_queue.sum(&:remaining_processing_time)) * 10
    puts "Max iterations calculated from process time: #{max_iterations}"

    ready_queue.each { |pcb| pcb.wait_time = 0 }
    waiting_queue.each { |pcb| pcb.wait_time = 0 }

    current_proc = scheduler.next_proc(:ready)
    # TODO allow file logging
    log = $stdout
    max_iterations.times do

      # Get the next proc
      next_proc = scheduler.next_proc(:ready, current_proc)
      break if next_proc.nil? && waiting_queue.empty?

      # If we reached this point, there are still processes in the waiting queue
      # but we have no current process or next process yet, so we should skip
      # the context switch and current_proc update steps
      if !next_proc.nil?
        if current_proc.nil? || next_proc != current_proc
          number_of_context_switches += 1
          log.puts "Perfroming context switch with #{next_proc}"
          ready_queue.push current_proc if !current_proc.nil?
          current_proc = next_proc
        end

        current_proc.remaining_processing_time -= 1

        if current_proc.remaining_processing_time <= 0
          log.puts "#{current_proc} Completed"

          # place proc in simulated 'success' and 'Free' proc
          completed_procs << current_proc
          current_proc = nil
        end
      end

      log.puts "Current Proc in CPU: #{current_proc}" if !current_proc.nil?

      # NOTE for now, at the end of each cycle one process is moved from the
      # waiting queue to the ready queue.
      if waiting_queue.any?
        _pcb = waiting_queue.pop
        _pcb.update_state("ready")
        ready_queue.push _pcb
        log.puts "New arrival to the :ready queue from the waiting queue. #{_pcb}"
      end

      # Increment all wait times
      ready_queue.each { |pcb| pcb.wait_time += 1 }
      waiting_queue.each { |pcb| pcb.wait_time += 1 }

      log.puts "Ready Queue: #{ready_queue}" if ready_queue.any?
    end

    if waiting_queue.any? || ready_queue.any? || !current_proc.nil?
      puts "Simulation did not finish within #{max_iterations} iterations."
      puts "This just means that our estimation for max iterations was off."
      puts "The average wait time will still be calculated."
    end
    puts "Completed Procs: #{completed_procs.inspect}"
    avg_waiting_time = completed_procs.sum(&:wait_time)
    avg_waiting_time += ready_queue.sum(&:wait_time) if ready_queue.any?
    avg_waiting_time += waiting_queue.sum(&:wait_time) if waiting_queue.any?
    divsor = total_procs > 0 ? total_procs : 1
    avg_waiting_time = avg_waiting_time / divsor
    avg_context_switches = number_of_context_switches.to_f / divsor

    puts "\n\nThe Results using the #{scheduler.class} are here:"
    puts "Average Wait Time: #{avg_waiting_time} time units"
    puts "Average Context Switches per Process: #{avg_context_switches}"
    puts "Total Number of Context Switches: #{number_of_context_switches}"
    puts "Total Processes: #{total_procs}"
    puts "Total Completed Procs: #{completed_procs.count}"

    @manager = orig_manager
  end

  def print_queues
    puts "Ready Queue: #{ready_queue}"
    puts "Waiting Queue: #{waiting_queue}"
    puts "Block Queue: #{blocked_queue}"
    true
  end

  def print_all
    puts "All Procs: #{procs}"
    true
  end

  def print_usage
    puts "The following are the accepted commands:"
    puts "help        - prints this usuage guide"
    puts "add_proc    - interactively adds a process to a queue"
    puts "delete_proc - interactively remove a process from a queue"
    puts "show_queues - prints queues to STDOUT"
    puts "show_procs  - prints all procs to STDOUT"
    puts "simulate [scheduler] - runs simulation with the given scheduler. Choices are sjf, robin, priority. Default is sjf."
    puts "load_pcbs [file] - load pcbs from the give file"
    puts "exit        - quits the program"
    puts "quit        - alias for exit"
    true
  end

  def add_proc_interactively
    pid = 0
    options = {
      state: "ready",
      priority: 4,
      remaining_processing_time: 8,
      arrival_time: 0,
      memory_required: 10,
      wait_time: 0,
    }

    puts "Enter process id"
    begin
      pid = Integer(Readline.readline('> ', true))
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    puts "Enter process' priority (hit enter to use default of 4)"
    begin
      ans = Readline.readline('> ', true)
      options[:priority] = Integer(ans) if !ans.empty?
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    puts "Enter process' remaining processing time (hit enter to use default of 8)"
    begin
      ans = Readline.readline('> ', true)
      options[:remaining_processing_time] = Integer(ans) if !ans.empty?
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    puts "Enter process' arrival time (hit enter to use default of 0)"
    begin
      ans = Readline.readline('> ', true)
      options[:arrival_time] = Integer(ans) if !ans.empty?
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    puts "Enter process' memory required (hit enter to use default of 10)"
    begin
      ans = Readline.readline('> ', true)
      options[:arrival_time] = Integer(ans) if !ans.empty?
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    puts "Which queue would the process enter? ('waiting', or 'ready')"
    begin
      state = Readline.readline('> ', true)
      case state
      when /^w(aiting)?/i
        options[:state] = "waiting"
      when /^r(eady)?/i
        options[:state] = "ready"
      else
        raise ArgumentError.new "state must be either 'ready' or 'waiting'"
      end
    rescue
      puts "Unrecognized queue: '#{state}', please enter a valid queue (ready,waiting)"
      retry
    end

    pcb = RubyOS::PCB.new(pid, options)
    procs.push pcb

    print_all
    true
  end

  def delete_proc_interactively
    queue = nil

    puts "Which queue do you want to delete from? ('waiting', or 'ready')"
    begin
      print ">"
      state = $stdin.gets.chomp
      case state
      when /^w(aiting)?/i
        state = "waiting"
        queue = waiting_queue
      when /^r(eady)?/i
        state = "ready"
        queue = ready_queue
      else
        raise ArgumentError.new "state must be either 'ready' or 'waiting'"
      end
    rescue
      puts "Unrecognized queue '#{state}', please enter a valid queue (ready,waiting)"
      retry
    end

    puts "Enter the PID of the process you wish to remove (hit enter to use the default location)"
    begin
      print ">"
      pos = $stdin.gets.chomp
      pos = if pos.empty?
              nil
            else
              Integer(pos)
            end
      pcb = queue.pop(pos)
    rescue ArgumentError
      puts "Value entered is not an integer, please enter integer value"
      retry
    end

    if pcb.nil?
      puts "No process was removed (possible gave a PID that didn't exist?)"
    else
      puts "Remove process: #{pcb}"
    end

    print_all
    true
  end

  private

  def defined_commands
    [
      "help",
      "add_proc",
      "delete_proc",
      "show_queues",
      "show_procs",
      "simulate",
      "load_pcbs",
      "exit",
      "quit",
    ]
  end

  # Ruby is a pass-by-value language, *but* all those values (by default) are
  # references to memory locations. As such we have to duplicate all the PCBs
  # and rebuild the Queues and Manager to duplicate the manager. All Ruby
  # objects have a 'dup' method, but that only does a shallow copy.
  def deep_copy_manager
    dup_ready_queue = RubyOS::Queue.new ready_queue.map { |pcb| RubyOS::PCB.new pcb.pid, pcb.accounting_information.dup }
    dup_waiting_queue = RubyOS::Queue.new waiting_queue.map { |pcb| RubyOS::PCB.new pcb.pid, pcb.accounting_information.dup }
    dup_blocked_queue = RubyOS::Queue.new blocked_queue.map { |pcb| RubyOS::PCB.new pcb.pid, pcb.accounting_information.dup }
    mapping = { ready: dup_ready_queue,
                waiting: dup_waiting_queue,
                blocked: dup_blocked_queue }
    RubyOS::QueueManager.new mapping
  end

  def sort_process_by_arrival!
    procs.sort_by! { |pcb| [pcb.arrival_time, pcb.pid] }
  end

  def ready_queue
    manager[:ready]
  end

  def waiting_queue
    manager[:waiting]
  end

  def blocked_queue
    manager[:blocked]
  end

  def procs
    @procs ||= RubyOS::Queue.new
  end

end

RubyOS::Simulation.run
